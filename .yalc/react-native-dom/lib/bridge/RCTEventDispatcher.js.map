{"version":3,"sources":["../../ReactDom/bridge/RCTEventDispatcher.js"],"names":["normalizeInputEventName","RCTTextEventType","RCTTextEventTypeFocus","RCTTextEventTypeBlur","RCTTextEventTypeChange","RCTTextEventTypeSubmit","RCTTextEventTypeEnd","RCTTextEventTypeKeyPress","capitalizeFirstLetter","string","charAt","toUpperCase","slice","eventName","startsWith","substring","stringToHash","input","hash","chr","length","i","charCodeAt","RCTEventDispatcher","event","viewTag","coalescingKey","bridge","events","eventQueue","eventsDispatchScheduled","observers","Set","name","body","enqueueJSCall","target","type","reactTag","text","key","eventCount","sendInputEvent","observer","eventDispatcherWillDispatchEvent","eventID","RCTGetEventID","previousEvent","canCoalesce","coalesceWithEvent","push","scheduleEventsDispatch","flushEventsQueue","enqueueJSCallWithDotMethod","moduleDotMethod","arguments","forEach","eventId","dispatchEvent","add","delete"],"mappings":"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","file":"RCTEventDispatcher.js","sourcesContent":["/**\n * @providesModule RCTEventDispatcher\n * @flow\n */\n\nimport RCTBridge, {\n  RCT_EXPORT_MODULE,\n  RCT_EXPORT_METHOD,\n  RCTFunctionTypeNormal\n} from \"RCTBridge\";\nimport invariant from \"Invariant\";\n\nexport const RCTTextEventType = {\n  RCTTextEventTypeFocus: 0,\n  RCTTextEventTypeBlur: 1,\n  RCTTextEventTypeChange: 2,\n  RCTTextEventTypeSubmit: 3,\n  RCTTextEventTypeEnd: 4,\n  RCTTextEventTypeKeyPress: 5\n};\n\nexport interface RCTEvent {\n  viewTag: number;\n  eventName: string;\n  coalescingKey: number;\n\n  canCoalesce(): boolean;\n  coalesceWithEvent(event: RCTEvent): RCTEvent;\n\n  moduleDotMethod(): string;\n  arguments(): Array<any>;\n}\n\nexport interface RCTEventDispatcherObserver {\n  eventDispatcherWillDispatchEvent(event: RCTEvent): void;\n}\n\nfunction capitalizeFirstLetter(string) {\n  return string.charAt(0).toUpperCase() + string.slice(1);\n}\n\nexport function normalizeInputEventName(eventName: string) {\n  if (eventName.startsWith(\"on\")) {\n    eventName = `top${eventName.substring(2)}`;\n  } else if (!eventName.startsWith(\"top\")) {\n    eventName = `top${capitalizeFirstLetter(eventName)}`;\n  }\n\n  return eventName;\n}\n\nfunction stringToHash(input: string): number {\n  let hash = 0,\n    chr;\n  if (input.length === 0) return hash;\n  for (let i = 0; i < input.length; i++) {\n    chr = input.charCodeAt(i);\n    hash = (hash << 5) - hash + chr;\n    hash |= 0; // Convert to 32bit integer\n  }\n  return hash;\n}\n\n@RCT_EXPORT_MODULE(\"RCTEventDispatcher\")\nclass RCTEventDispatcher {\n  bridge: RCTBridge;\n  events: { [number]: RCTEvent };\n  eventQueue: Array<number>;\n  // queueLock ??\n  eventsDispatchScheduled: boolean;\n  observers: Set<RCTEventDispatcherObserver>;\n  // observersLock ??\n\n  static RCTGetEventID(event: RCTEvent): number {\n    return (\n      event.viewTag |\n      ((stringToHash(event.eventName) & 0xffff) << 32) |\n      (event.coalescingKey << 48)\n    );\n  }\n\n  constructor(bridge: RCTBridge) {\n    this.bridge = bridge;\n    this.events = {};\n    this.eventQueue = [];\n    this.eventsDispatchScheduled = false;\n    this.observers = new Set();\n    return this;\n  }\n\n  sendDeviceEvent(name: string, body: ?Object) {\n    this.bridge.enqueueJSCall(\n      \"RCTDeviceEventEmitter\",\n      \"emit\",\n      body ? [name, body] : [name]\n    );\n  }\n\n  sendInputEvent(name: string, body: Object) {\n    name = normalizeInputEventName(name);\n    this.bridge.enqueueJSCall(\"RCTEventEmitter\", \"receiveEvent\", [\n      body.target,\n      name,\n      body\n    ]);\n  }\n\n  /**\n   * Send a text input/focus event. For internal use only.\n   */\n  sendTextEvent(\n    type: number,\n    reactTag: number,\n    text: string,\n    key: string,\n    eventCount: number\n  ) {\n    const events = [\n      \"focus\",\n      \"blur\",\n      \"change\",\n      \"submitEditing\",\n      \"endEditing\",\n      \"keyPress\"\n    ];\n\n    const body: Object = {\n      eventCount,\n      target: reactTag\n    };\n\n    if (text) {\n      body.text = text;\n    }\n\n    if (key) {\n      // TODO: Key Event Handling\n    }\n\n    this.sendInputEvent(events[type], body);\n  }\n\n  /**\n   * Send a pre-prepared event object.\n   *\n   * Events are sent to JS as soon as the thread is free to process them.\n   * If an event can be coalesced and there is another compatible event waiting, the coalescing will happen immediately.\n   */\n  sendEvent(event: RCTEvent) {\n    for (let observer of this.observers) {\n      observer.eventDispatcherWillDispatchEvent(event);\n    }\n\n    const eventID = RCTEventDispatcher.RCTGetEventID(event);\n\n    const previousEvent = this.events[eventID];\n    if (previousEvent) {\n      invariant(\n        event.canCoalesce(),\n        `Got event which cannot be coalesced, but has the same eventID ${eventID} as the previous event`\n      );\n      event = previousEvent.coalesceWithEvent(previousEvent);\n    } else {\n      this.eventQueue.push(eventID);\n    }\n\n    this.events[eventID] = event;\n\n    let scheduleEventsDispatch = false;\n    if (!this.eventsDispatchScheduled) {\n      this.eventsDispatchScheduled = true;\n      scheduleEventsDispatch = true;\n    }\n\n    if (scheduleEventsDispatch) {\n      this.flushEventsQueue();\n    }\n  }\n\n  dispatchEvent(event: RCTEvent) {\n    this.bridge.enqueueJSCallWithDotMethod(\n      event.moduleDotMethod(),\n      event.arguments()\n    );\n  }\n\n  flushEventsQueue() {\n    const events = { ...this.events };\n    this.events = {};\n\n    const eventQueue = [...this.eventQueue];\n    this.eventQueue = [];\n\n    this.eventsDispatchScheduled = false;\n\n    eventQueue.forEach((eventId) => {\n      this.dispatchEvent(events[eventId]);\n    });\n  }\n\n  addDispatchObserver(observer: RCTEventDispatcherObserver) {\n    this.observers.add(observer);\n  }\n\n  removeDispatchObserver(observer: RCTEventDispatcherObserver) {\n    this.observers.delete(observer);\n  }\n}\n\nexport default RCTEventDispatcher;\n"]}