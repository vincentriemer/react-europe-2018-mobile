{"version":3,"sources":["../../ReactDom/modules/RCTUIManagerObserver.js"],"names":["RCTUIManagerObserverCoordinator","uiManagerWillPerformLayout","manager","observers","observer","uiManagerDidPerformLayout","uiManagerWillFlushBlocks","Set","add","delete"],"mappings":"mTAKA,gDACA,yC,uDACA,yD,mJA6BMA,gC,YAGJ,0CAAc,wFAkBdC,0BAlBc,CAkBe,SAACC,OAAD,CAA2B,CACtD,kBAAqB,MAAKC,SAA1B,oLAAqC,uIAA5BC,SAA4B,MACnC,GAAI,MAAOA,UAASH,0BAAhB,GAA+C,UAAnD,CAA+D,CAE7DG,SAASC,yBAAT,CAAmCH,OAAnC,EACD,CACF,CACF,CAzBa,MA2BdG,yBA3Bc,CA2Bc,SAACH,OAAD,CAA2B,CACrD,mBAAqB,MAAKC,SAA1B,2LAAqC,mJAA5BC,SAA4B,OACnC,GAAI,MAAOA,UAASC,yBAAhB,GAA8C,UAAlD,CAA8D,CAC5DD,SAASC,yBAAT,CAAmCH,OAAnC,EACD,CACF,CACF,CAjCa,MAmCdI,wBAnCc,CAmCa,SAACJ,OAAD,CAA2B,CACpD,mBAAqB,MAAKC,SAA1B,2LAAqC,mJAA5BC,SAA4B,OACnC,GAAI,MAAOA,UAASE,wBAAhB,GAA6C,UAAjD,CAA6D,CAC3DF,SAASE,wBAAT,CAAkCJ,OAAlC,EACD,CACF,CACF,CAzCa,CACZ,KAAKC,SAAL,CAAiB,GAAII,IAAJ,EAAjB,CACD,C,yGAKWH,Q,CAAgC,CAC1C,KAAKD,SAAL,CAAeK,GAAf,CAAmBJ,QAAnB,EACD,C,sDAKcA,Q,CAAgC,CAC7C,KAAKD,SAAL,CAAeM,MAAf,CAAsBL,QAAtB,EACD,C,+DA4BYJ,+B","file":"RCTUIManagerObserver.js","sourcesContent":["/**\n * @providesModule RCTUIManagerObserverCoordinator\n * @flow\n */\n\nimport { getPropertyNames } from \"RCTBridge\";\nimport memoize from \"fast-memoize\";\nimport RCTViewManager from \"RCTViewManager\";\n\nimport typeof _RCTUIManager from \"RCTUIManager\";\ntype RCTUIManager = $Call<$await<_RCTUIManager>>;\n\nexport interface RCTUIManagerObserver {\n  /**\n   * Called just before the UIManager layout views.\n   * It allows performing some operation for components which contain custom\n   * layout logic right before regular Yoga based layout. So, for instance,\n   * some components which have own React-independent state can compute and cache\n   * own intrinsic content size (which will be used by Yoga) at this point.\n   */\n  uiManagerWillPerformLayout?: (manager: RCTUIManager) => void;\n\n  /**\n   * Called just after the UIManager layout views.\n   * It allows performing custom layout logic right after regular Yoga based layout.\n   * So, for instance, this can be used for computing final layout for a component,\n   * since it has its final frame set by Yoga at this point.\n   */\n  uiManagerDidPerformLayout?: (manager: RCTUIManager) => void;\n\n  /**\n   * Called before flushing UI blocks at the end of a batch.\n   */\n  uiManagerWillFlushBlocks?: (manager: RCTUIManager) => void;\n}\n\nclass RCTUIManagerObserverCoordinator implements RCTUIManagerObserver {\n  observers: Set<RCTUIManagerObserver>;\n\n  constructor() {\n    this.observers = new Set();\n  }\n\n  /**\n   * Add a UIManagerObserver. See the `RCTUIManagerObserver` iterface for more info.\n   */\n  addObserver(observer: RCTUIManagerObserver) {\n    this.observers.add(observer);\n  }\n\n  /**\n   * Remove a `UIManagerObserver`.\n   */\n  removeObserver(observer: RCTUIManagerObserver) {\n    this.observers.delete(observer);\n  }\n\n  uiManagerWillPerformLayout = (manager: RCTUIManager) => {\n    for (let observer of this.observers) {\n      if (typeof observer.uiManagerWillPerformLayout === \"function\") {\n        // $FlowFixMe - I don't know why this fails when the other methods don't\n        observer.uiManagerDidPerformLayout(manager);\n      }\n    }\n  };\n\n  uiManagerDidPerformLayout = (manager: RCTUIManager) => {\n    for (let observer of this.observers) {\n      if (typeof observer.uiManagerDidPerformLayout === \"function\") {\n        observer.uiManagerDidPerformLayout(manager);\n      }\n    }\n  };\n\n  uiManagerWillFlushBlocks = (manager: RCTUIManager) => {\n    for (let observer of this.observers) {\n      if (typeof observer.uiManagerWillFlushBlocks === \"function\") {\n        observer.uiManagerWillFlushBlocks(manager);\n      }\n    }\n  };\n}\n\nexport default RCTUIManagerObserverCoordinator;\n"]}