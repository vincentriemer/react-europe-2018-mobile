{"version":3,"sources":["../../ReactDom/modules/RCTBlobManager.js"],"names":["kBlobURIScheme","RCTBlobManager","bridge","blobs","BLOB_URI_SCHEME","BLOB_URI_HOST","data","blobId","storeWithId","blob","offset","size","resolveWithOffsetAndSize","url","parsedUrl","URL","pathname","parseInt","searchParams","get","slice","networking","addRequestHandler","addResponseHandler","resolve","contentType","blobType","type","body","responseType","response","Blob","store","name","getResponseHeader"],"mappings":"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","file":"RCTBlobManager.js","sourcesContent":["/**\n * @providesModule RCTBlobManager\n * @flow\n */\n\nimport RCTBridge, {\n  RCT_EXPORT_MODULE,\n  RCT_EXPORT_METHOD,\n  RCTFunctionTypeNormal\n} from \"RCTBridge\";\nimport cuid from \"cuid\";\nimport invariant from \"invariant\";\n\nimport type {\n  RCTNetworkingRequestHandler,\n  RCTNetworkingResponseHandler,\n  RCTHttpRequest\n} from \"RCTNetworkingNative\";\n\nconst kBlobURIScheme = \"blob\";\n\n@RCT_EXPORT_MODULE(\"BlobModule\")\nclass RCTBlobManager\n  implements RCTNetworkingRequestHandler, RCTNetworkingResponseHandler {\n  bridge: RCTBridge;\n  blobs: { [key: string]: Blob };\n\n  constructor(bridge: RCTBridge) {\n    this.bridge = bridge;\n    this.blobs = {};\n  }\n\n  constantsToExport() {\n    return {\n      BLOB_URI_SCHEME: kBlobURIScheme,\n      BLOB_URI_HOST: null\n    };\n  }\n\n  store(data: Blob) {\n    const blobId = cuid();\n    this.storeWithId(data, blobId);\n    return blobId;\n  }\n\n  storeWithId(data: Blob, blobId: string) {\n    this.blobs[blobId] = data;\n  }\n\n  resolve(blob: Object) {\n    const blobId: string = blob[\"blobId\"];\n    const offset: number = blob[\"offset\"];\n    const size: number = blob[\"size\"];\n    return this.resolveWithOffsetAndSize(blobId, offset, size);\n  }\n\n  resolveURL(url: string) {\n    const parsedUrl = new URL(url);\n    const blobId = parsedUrl.pathname;\n    const offset = parseInt(parsedUrl.searchParams.get(\"offset\"), 10);\n    const size = parseInt(parsedUrl.searchParams.get(\"size\"), 10);\n    return this.resolveWithOffsetAndSize(blobId, offset, size);\n  }\n\n  resolveWithOffsetAndSize(blobId: string, offset: number, size: number) {\n    let data = this.blobs[blobId];\n    if (!data) {\n      return null;\n    }\n    if (offset != 0 || (size != -1 && size != data.size)) {\n      data = data.slice(offset, offset + size);\n    }\n    return data;\n  }\n\n  @RCT_EXPORT_METHOD(RCTFunctionTypeNormal)\n  addNetworkingHandler() {\n    this.bridge.networking.addRequestHandler(this);\n    this.bridge.networking.addResponseHandler(this);\n  }\n\n  @RCT_EXPORT_METHOD(RCTFunctionTypeNormal)\n  release(blobId: string) {\n    delete this.blobs[blobId];\n  }\n\n  canHandleNetworkingRequest(data: Object): boolean {\n    return data.blob != null;\n  }\n\n  handleNetworkingRequest(data: Object): Object {\n    const blob: ?Blob = this.resolve(data.blob);\n    invariant(blob, `Could not resolve blob ${data.blob}`);\n\n    let contentType = \"application/octet-stream\";\n    const blobType = blob.type;\n    if (blobType != null && blob.size !== 0) {\n      contentType = blob.type;\n    }\n    return { body: blob, contentType };\n  }\n\n  canHandleNetworkingResponse(responseType: string): boolean {\n    return responseType === \"blob\";\n  }\n\n  handleNetworkingResponse(response: RCTHttpRequest, data: Blob): Object {\n    data = data ? data : new Blob();\n    return {\n      blobId: this.store(data),\n      offset: 0,\n      size: data.size,\n      name: null,\n      type: response.getResponseHeader(\"content-type\")\n    };\n  }\n}\n\nexport default RCTBlobManager;\n"]}