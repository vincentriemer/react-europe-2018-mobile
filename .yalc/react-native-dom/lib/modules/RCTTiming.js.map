{"version":3,"sources":["../../ReactDom/modules/RCTTiming.js"],"names":["IDLE_CALLBACK_THRESHOLD","now","window","performance","Date","RCTTiming","bridge","timers","sendIdleEvents","targetFrameDuration","callbackId","duration","jsSchedulingTime","repeats","currentTimeMillis","currentDateNowTimeMillis","adjustedDuration","Math","max","initialTargetTime","timer","String","enqueueJSCall","sendIdle","toRemove","time","t","push","length","frameStart","frameNow","frameElapsed","Object","keys"],"mappings":"udAKA,gD,0xBAaA,GAAMA,yBAA0B,CAAhC,CAEA,QAASC,IAAT,EAAe,CACb,MAAOC,QAAOC,WAAP,CAAqBA,YAAYF,GAAZ,EAArB,CAAyCG,KAAKH,GAAL,EAAhD,CACD,C,GAGKI,U,OADL,iCAAkB,WAAlB,C,OAcE,kE,OAiCA,kE,OAKA,kE,iCA7CD,mBAAYC,MAAZ,CAA+B,8CAC7B,KAAKA,MAAL,CAAcA,MAAd,CACA,KAAKC,MAAL,CAAc,EAAd,CACA,KAAKC,cAAL,CAAsB,KAAtB,CACA,KAAKC,mBAAL,CAA2B,OAAS,IAApC,CACD,C,mFAICC,U,CACAC,Q,CACAC,gB,CACAC,O,CACA,CACA,GAAMC,mBAAoBb,KAA1B,CACA,GAAMc,0BAA2BH,iBAAmB,KAAO,EAA3D,CACA,GAAMI,kBAAmBC,KAAKC,GAAL,CACvB,GADuB,CAEvBN,iBAAmBG,wBAAnB,CAA8CJ,QAFvB,CAAzB,CAIA,GAAMQ,mBAAoBL,kBAAoBE,gBAA9C,CAEA,GAAMI,OAAQ,CACZV,qBADY,CAEZC,iBAFY,CAGZC,iBAAkBO,iBAHN,CAIZN,eAJY,CAAd,CAOA,GAAIG,mBAAqB,CAAzB,CAA4B,CAC1B,GAAII,MAAMP,OAAV,CAAmB,CACjBO,MAAMR,gBAAN,EAA0BQ,MAAMT,QAAhC,CACA,KAAKJ,MAAL,CAAYc,OAAOX,UAAP,CAAZ,EAAkCU,KAAlC,CACD,CACD,KAAKd,MAAL,CAAYgB,aAAZ,CAA0B,UAA1B,CAAsC,YAAtC,CAAoD,CAAC,CAACZ,UAAD,CAAD,CAApD,EACD,CAND,IAMO,CACL,KAAKH,MAAL,CAAYc,OAAOX,UAAP,CAAZ,EAAkCU,KAAlC,CACD,CACF,C,gDAGWV,U,CAAoB,CAC9B,MAAO,MAAKH,MAAL,CAAYc,OAAOX,UAAP,CAAZ,CAAP,CACD,C,4DAGiBa,Q,CAAmB,CACnC,KAAKf,cAAL,CAAsBe,QAAtB,CACD,C,0NAGOC,Q,CAAW,E,CACXjB,M,CAAS,E,CACTkB,I,CAAOxB,K,CAEb,IAAWmB,KAAX,GAAoB,MAAKb,MAAzB,CAAiC,CACzBmB,CADyB,CACrB,KAAKnB,MAAL,CAAYa,KAAZ,CADqB,CAE/B,GAAIM,EAAEd,gBAAF,EAAsBa,IAA1B,CAAgC,CAC9BlB,OAAOoB,IAAP,CAAY,KAAKpB,MAAL,CAAYa,KAAZ,EAAmBV,UAA/B,EACA,GAAIgB,EAAEb,OAAN,CAAe,CACba,EAAEd,gBAAF,EAAsBc,EAAEf,QAAxB,CACD,CAFD,IAEO,CACLa,SAASG,IAAT,CAAcP,KAAd,EACD,CACF,CACF,CAID,GAAIb,OAAOqB,MAAX,CAAmB,CACjB,KAAKtB,MAAL,CAAYgB,aAAZ,CAA0B,UAA1B,CAAsC,YAAtC,CAAoD,CAACf,MAAD,CAApD,EACD,C,UAEmBiB,Q,0eAATJ,M,MACT,MAAO,MAAKb,MAAL,CAAYa,MAAZ,CAAP,C,yHAIOS,U,kJACJ,KAAKrB,c,mEAGJsB,Q,CAAW7B,K,CACX8B,Y,CAAeD,SAAWD,U,CAChC,GAAI,KAAKpB,mBAAL,CAA2BsB,YAA3B,EAA2C/B,uBAA/C,CAAwE,CACtE,KAAKM,MAAL,CAAYgB,aAAZ,CAA0B,UAA1B,CAAsC,mBAAtC,CAA2D,CACzDlB,KAAKH,GAAL,GAAa8B,YAD4C,CAA3D,EAGD,C,gHAGuB,CACxB,MAAOC,QAAOC,IAAP,CAAY,KAAK1B,MAAjB,EAAyBqB,MAAzB,GAAoC,CAA3C,CACD,C,4gBAGYvB,S","file":"RCTTiming.js","sourcesContent":["/**\n * @providesModule RCTTiming\n * @flow\n */\n\nimport RCTBridge, {\n  RCT_EXPORT_MODULE,\n  RCT_EXPORT_METHOD,\n  RCTFunctionTypeNormal\n} from \"RCTBridge\";\n\ntype Timer = {\n  callbackId: number,\n  duration: number,\n  jsSchedulingTime: number,\n  repeats: boolean\n};\n\nconst IDLE_CALLBACK_THRESHOLD = 1; // Minimum idle execution time of 1ms\n\nfunction now() {\n  return window.performance ? performance.now() : Date.now();\n}\n\n@RCT_EXPORT_MODULE(\"RCTTiming\")\nclass RCTTiming {\n  bridge: RCTBridge;\n  timers: { [callbackId: string]: Timer };\n  sendIdleEvents: boolean;\n  targetFrameDuration: number;\n\n  constructor(bridge: RCTBridge) {\n    this.bridge = bridge;\n    this.timers = {};\n    this.sendIdleEvents = false;\n    this.targetFrameDuration = 1000.0 / 60.0; // 60fps\n  }\n\n  @RCT_EXPORT_METHOD(RCTFunctionTypeNormal)\n  createTimer(\n    callbackId: number,\n    duration: number,\n    jsSchedulingTime: number,\n    repeats: boolean\n  ) {\n    const currentTimeMillis = now();\n    const currentDateNowTimeMillis = jsSchedulingTime + 1000 / 60;\n    const adjustedDuration = Math.max(\n      0.0,\n      jsSchedulingTime - currentDateNowTimeMillis + duration\n    );\n    const initialTargetTime = currentTimeMillis + adjustedDuration;\n\n    const timer = {\n      callbackId,\n      duration,\n      jsSchedulingTime: initialTargetTime,\n      repeats\n    };\n\n    if (adjustedDuration === 0) {\n      if (timer.repeats) {\n        timer.jsSchedulingTime += timer.duration;\n        this.timers[String(callbackId)] = timer;\n      }\n      this.bridge.enqueueJSCall(\"JSTimers\", \"callTimers\", [[callbackId]]);\n    } else {\n      this.timers[String(callbackId)] = timer;\n    }\n  }\n\n  @RCT_EXPORT_METHOD(RCTFunctionTypeNormal)\n  deleteTimer(callbackId: number) {\n    delete this.timers[String(callbackId)];\n  }\n\n  @RCT_EXPORT_METHOD(RCTFunctionTypeNormal)\n  setSendIdleEvents(sendIdle: boolean) {\n    this.sendIdleEvents = sendIdle;\n  }\n\n  async frame() {\n    const toRemove = [];\n    const timers = [];\n    const time = now();\n\n    for (const timer in this.timers) {\n      const t = this.timers[timer];\n      if (t.jsSchedulingTime <= time) {\n        timers.push(this.timers[timer].callbackId);\n        if (t.repeats) {\n          t.jsSchedulingTime += t.duration;\n        } else {\n          toRemove.push(timer);\n        }\n      }\n    }\n\n    // timer information is distributed in a single message with mulitiple params\n    // which minimizes the bridge traffic when many timers are used\n    if (timers.length) {\n      this.bridge.enqueueJSCall(\"JSTimers\", \"callTimers\", [timers]);\n    }\n\n    for (const timer of toRemove) {\n      delete this.timers[timer];\n    }\n  }\n\n  async idle(frameStart: number) {\n    if (!this.sendIdleEvents) {\n      return;\n    }\n    const frameNow = now();\n    const frameElapsed = frameNow - frameStart;\n    if (this.targetFrameDuration - frameElapsed >= IDLE_CALLBACK_THRESHOLD) {\n      this.bridge.enqueueJSCall(\"JSTimers\", \"callIdleCallbacks\", [\n        Date.now() - frameElapsed\n      ]);\n    }\n  }\n\n  shouldContinue(): boolean {\n    return Object.keys(this.timers).length !== 0;\n  }\n}\n\nexport default RCTTiming;\n"]}