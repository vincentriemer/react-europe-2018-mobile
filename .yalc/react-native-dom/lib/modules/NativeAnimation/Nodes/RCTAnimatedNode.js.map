{"version":3,"sources":["../../../../ReactDom/modules/NativeAnimation/Nodes/RCTAnimatedNode.js"],"names":["RCTAnimatedNode","tag","config","nodeTag","child","childNodes","onAttachedToNode","onDetachedFromNode","parent","parentNodes","Object","values","forEach","removeChild","needsUpdate","setNeedsUpdate","updateNodeIfNecessary","performUpdate"],"mappings":"mTAQA,qD,yIAEMA,gB,YASJ,yBAAYC,GAAZ,CAAyBC,MAAzB,CAAyC,oDACvC,KAAKC,OAAL,CAAeF,GAAf,CACA,KAAKC,MAAL,CAAcA,MAAd,CACD,C,mFAEQE,K,CAAyB,CAChC,GAAI,CAAC,KAAKC,UAAV,CAAsB,CACpB,KAAKA,UAAL,CAAkB,EAAlB,CACD,CACD,GAAID,KAAJ,CAAW,CACT,KAAKC,UAAL,CAAgBD,MAAMD,OAAtB,EAAiCC,KAAjC,CACAA,MAAME,gBAAN,CAAuB,IAAvB,EACD,CACF,C,gDAEWF,K,CAAwB,CAClC,GAAI,CAAC,KAAKC,UAAV,CAAsB,CACpB,OACD,CACD,GAAID,KAAJ,CAAW,CACT,MAAO,MAAKC,UAAL,CAAgBD,MAAMD,OAAtB,CAAP,CACAC,MAAMG,kBAAN,CAAyB,IAAzB,EACD,CACF,C,0DAEgBC,M,CAAyB,CACxC,GAAI,CAAC,KAAKC,WAAV,CAAuB,CACrB,KAAKA,WAAL,CAAmB,EAAnB,CACD,CACD,GAAID,MAAJ,CAAY,CACV,KAAKC,WAAL,CAAiBD,OAAOL,OAAxB,EAAmCK,MAAnC,CACD,CACF,C,8DAEkBA,M,CAAyB,CAC1C,GAAI,CAAC,KAAKC,WAAV,CAAuB,CACrB,OACD,CACD,GAAID,MAAJ,CAAY,CACV,MAAO,MAAKC,WAAL,CAAiBD,OAAOL,OAAxB,CAAP,CACD,CACF,C,+CAEY,gBACX,GAAI,KAAKM,WAAT,CAAsB,CACpBC,OAAOC,MAAP,CAAc,KAAKF,WAAnB,EAAgCG,OAAhC,CAAwC,SAACJ,MAAD,CAAY,CAElDA,OAAOK,WAAP,QACD,CAHD,EAID,CACD,GAAI,KAAKR,UAAT,CAAqB,CACnBK,OAAOC,MAAP,CAAc,KAAKN,UAAnB,EAA+BO,OAA/B,CAAuC,SAACR,KAAD,CAAW,CAEhD,MAAKS,WAAL,CAAiBT,KAAjB,EACD,CAHD,EAID,CACF,C,uDAEgB,CACf,KAAKU,WAAL,CAAmB,IAAnB,CACA,GAAI,KAAKT,UAAT,CAAqB,CACnBK,OAAOC,MAAP,CAAc,KAAKN,UAAnB,EAA+BO,OAA/B,CAAuC,SAACR,KAAD,CAAW,CAEhDA,MAAMW,cAAN,GACD,CAHD,EAID,CACF,C,qEAEuB,CACtB,GAAI,KAAKD,WAAT,CAAsB,CACpB,GAAI,KAAKL,WAAT,CAAsB,CACpBC,OAAOC,MAAP,CAAc,KAAKF,WAAnB,EAAgCG,OAAhC,CAAwC,SAACJ,MAAD,CAAY,CAElDA,OAAOQ,qBAAP,GACD,CAHD,EAID,CACD,KAAKC,aAAL,GACD,CACF,C,qDAEe,CACd,KAAKH,WAAL,CAAmB,KAAnB,CAID,C,+CAGYd,e","file":"RCTAnimatedNode.js","sourcesContent":["/**\n * @providesModule RCTAnimatedNode\n * @flow\n */\n\nimport type { Config } from \"RCTNativeAnimatedModule\";\nimport type RCTNativeAnimatedNodesManager from \"RCTNativeAnimatedNodesManager\";\n\nimport invariant from \"Invariant\";\n\nclass RCTAnimatedNode {\n  nodeTag: number;\n  needsUpdate: boolean;\n  config: Config;\n  manager: RCTNativeAnimatedNodesManager;\n\n  childNodes: ?{ [nodeTag: number]: RCTAnimatedNode };\n  parentNodes: ?{ [nodeTag: number]: RCTAnimatedNode };\n\n  constructor(tag: number, config: Config) {\n    this.nodeTag = tag;\n    this.config = config;\n  }\n\n  addChild(child: ?RCTAnimatedNode) {\n    if (!this.childNodes) {\n      this.childNodes = {};\n    }\n    if (child) {\n      this.childNodes[child.nodeTag] = child;\n      child.onAttachedToNode(this);\n    }\n  }\n\n  removeChild(child: RCTAnimatedNode) {\n    if (!this.childNodes) {\n      return;\n    }\n    if (child) {\n      delete this.childNodes[child.nodeTag];\n      child.onDetachedFromNode(this);\n    }\n  }\n\n  onAttachedToNode(parent: RCTAnimatedNode) {\n    if (!this.parentNodes) {\n      this.parentNodes = {};\n    }\n    if (parent) {\n      this.parentNodes[parent.nodeTag] = parent;\n    }\n  }\n\n  onDetachedFromNode(parent: RCTAnimatedNode) {\n    if (!this.parentNodes) {\n      return;\n    }\n    if (parent) {\n      delete this.parentNodes[parent.nodeTag];\n    }\n  }\n\n  detachNode() {\n    if (this.parentNodes) {\n      Object.values(this.parentNodes).forEach((parent) => {\n        // $FlowFixMe - Flow considers the return for Object.values to be Array<mixed>\n        parent.removeChild(this);\n      });\n    }\n    if (this.childNodes) {\n      Object.values(this.childNodes).forEach((child) => {\n        // $FlowFixMe - Flow considers the return for Object.values to be Array<mixed>\n        this.removeChild(child);\n      });\n    }\n  }\n\n  setNeedsUpdate() {\n    this.needsUpdate = true;\n    if (this.childNodes) {\n      Object.values(this.childNodes).forEach((child) => {\n        // $FlowFixMe - Flow considers the return for Object.values to be Array<mixed>\n        child.setNeedsUpdate();\n      });\n    }\n  }\n\n  updateNodeIfNecessary() {\n    if (this.needsUpdate) {\n      if (this.parentNodes) {\n        Object.values(this.parentNodes).forEach((parent) => {\n          // $FlowFixMe - Flow considers the return for Object.values to be Array<mixed>\n          parent.updateNodeIfNecessary();\n        });\n      }\n      this.performUpdate();\n    }\n  }\n\n  performUpdate() {\n    this.needsUpdate = false;\n    // To be overidden by subclasses\n    // This method is called on a node only if it has been marked for update\n    // during the current update loop\n  }\n}\n\nexport default RCTAnimatedNode;\n"]}