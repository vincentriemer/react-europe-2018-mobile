{"version":3,"sources":["../../../../ReactDom/modules/NativeAnimation/Drivers/RCTFrameAnimation.js"],"names":["RCTFrameAnimation","animationId","config","valueNode","callback","toValue","fromValue","value","frames","iterations","currentLoop","animationHasBegun","animationHasFinished","animationStartTime","animationCurrentTIme","finished","currentTime","length","currentDuration","startIndex","Math","floor","nextIndex","firstValue","updateOutputWithFrameOutput","finalValue","fromFrameValue","toFrameValue","fromInterval","toInterval","frameOutput","outputValue","setNeedsUpdate"],"mappings":"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","file":"RCTFrameAnimation.js","sourcesContent":["/**\n * @providesModule RCTFrameAnimation\n * @flow\n */\n\nimport type { Config } from \"RCTNativeAnimatedModule\";\nimport type { RCTAnimationDriver } from \"RCTAnimationDriver\";\nimport type RCTValueAnimatedNode from \"RCTValueAnimatedNode\";\n\nimport { RCTSingleFrameInterval } from \"RCTAnimationDriver\";\nimport { RCTInterpolateValue } from \"RCTAnimationUtils\";\n\nclass RCTFrameAnimation implements RCTAnimationDriver {\n  animationId: number;\n  valueNode: RCTValueAnimatedNode;\n  animationHasBegun: boolean;\n  animationHasFinished: boolean;\n\n  animationStartTime: number;\n  animationCurrentTIme: number;\n\n  frames: number[];\n  toValue: number;\n  fromValue: number;\n  callback: ?Function;\n  iterations: number;\n  currentLoop: number;\n\n  constructor(\n    animationId: number,\n    config: Config,\n    valueNode: RCTValueAnimatedNode,\n    callback: ?Function\n  ) {\n    this.animationId = animationId;\n    this.toValue = config.toValue != null ? config.toValue : 1;\n    this.fromValue = valueNode.value;\n    this.valueNode = valueNode;\n    this.frames = [...config.frames];\n    this.callback = callback;\n    this.iterations = config.iterations != null ? config.iterations : 1;\n    this.currentLoop = 1;\n    this.animationHasBegun = false;\n    this.animationHasFinished = this.iterations === 0;\n    return this;\n  }\n\n  startAnimation() {\n    this.animationStartTime = this.animationCurrentTIme = -1;\n    this.animationHasBegun = true;\n  }\n\n  stopAnimation() {\n    // this.valueNode = null;\n    if (this.callback) {\n      this.callback({\n        finished: this.animationHasFinished\n      });\n    }\n  }\n\n  stepAnimationWithTime(currentTime: number) {\n    if (\n      !this.animationHasBegun ||\n      this.animationHasFinished ||\n      this.frames.length === 0\n    ) {\n      // Animation has not begun or animation has already finished.\n      return;\n    }\n\n    if (this.animationStartTime === -1) {\n      this.animationStartTime = this.animationCurrentTIme = currentTime;\n    }\n\n    this.animationCurrentTIme = currentTime;\n    const currentDuration = this.animationCurrentTIme - this.animationStartTime;\n\n    // Determine how many frames have passed since last update.\n    // Get index of frames that surround the current interval\n    const startIndex = Math.floor(currentDuration / RCTSingleFrameInterval);\n    const nextIndex = startIndex + 1;\n\n    if (nextIndex >= this.frames.length) {\n      if (this.iterations == -1 || this.currentLoop < this.iterations) {\n        // Looping, reset to the first frame value.\n        this.animationStartTime = currentTime;\n        this.currentLoop++;\n        const firstValue = this.frames[0];\n        this.updateOutputWithFrameOutput(firstValue);\n      } else {\n        this.animationHasFinished = true;\n        // We are at the end of the animation\n        // Update value and flag animation has ended.\n        const finalValue = this.frames[this.frames.length - 1];\n        this.updateOutputWithFrameOutput(finalValue);\n      }\n      return;\n    }\n\n    // Do a linear remap of the two frames to safegaurd against variable framerates\n    const fromFrameValue = this.frames[startIndex];\n    const toFrameValue = this.frames[nextIndex];\n    const fromInterval = startIndex * RCTSingleFrameInterval;\n    const toInterval = nextIndex * RCTSingleFrameInterval;\n\n    // Interpolate between the individual frames to ensure the animations are\n    //smooth and of the proper duration regardless of the framerate.\n    const frameOutput = RCTInterpolateValue(\n      currentDuration,\n      fromInterval,\n      toInterval,\n      fromFrameValue,\n      toFrameValue,\n      \"extend\",\n      \"extend\"\n    );\n\n    this.updateOutputWithFrameOutput(frameOutput);\n  }\n\n  updateOutputWithFrameOutput(frameOutput: number) {\n    const outputValue = RCTInterpolateValue(\n      frameOutput,\n      0,\n      1,\n      this.fromValue,\n      this.toValue,\n      \"extend\",\n      \"extend\"\n    );\n\n    const valueNode = this.valueNode;\n    if (valueNode) {\n      valueNode.value = outputValue;\n      valueNode.setNeedsUpdate();\n    }\n  }\n}\n\nexport default RCTFrameAnimation;\n"]}