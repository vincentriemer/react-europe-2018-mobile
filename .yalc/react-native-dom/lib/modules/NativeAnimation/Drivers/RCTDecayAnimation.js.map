{"version":3,"sources":["../../../../ReactDom/modules/NativeAnimation/Drivers/RCTDecayAnimation.js"],"names":["RCTDecayAnimation","animationId","config","valueNode","callback","fromValue","lastValue","velocity","deceleration","iterations","currentLoop","animationHasFinished","frameStartTime","animationHasBegun","finished","currentTime","value","updateValue","Math","exp","abs","outputValue","setNeedsUpdate"],"mappings":"mTASA,wD,sFAEMA,kB,YAeJ,2BACEC,WADF,CAEEC,MAFF,CAGEC,SAHF,CAIEC,QAJF,CAKE,sDACA,KAAKH,WAAL,CAAmBA,WAAnB,CACA,KAAKI,SAAL,CAAiB,CAAjB,CACA,KAAKC,SAAL,CAAiB,CAAjB,CACA,KAAKH,SAAL,CAAiBA,SAAjB,CACA,KAAKC,QAAL,CAAgBA,QAAhB,CACA,KAAKG,QAAL,CAAgBL,OAAOK,QAAvB,CACA,KAAKC,YAAL,CAAoBN,OAAOM,YAA3B,CACA,KAAKC,UAAL,CAAkBP,OAAOO,UAAP,EAAqB,IAArB,CAA4BP,OAAOO,UAAnC,CAAgD,CAAlE,CACA,KAAKC,WAAL,CAAmB,CAAnB,CACA,KAAKC,oBAAL,CAA4B,KAAKF,UAAL,GAAoB,CAAhD,CACA,MAAO,KAAP,CACD,C,kGAEgB,CACf,KAAKG,cAAL,CAAsB,CAAC,CAAvB,CACA,KAAKC,iBAAL,CAAyB,IAAzB,CACD,C,qDAEe,CAEd,GAAI,KAAKT,QAAT,CAAmB,CACjB,KAAKA,QAAL,CAAc,CACZU,SAAU,KAAKH,oBADH,CAAd,EAGD,CACF,C,oEAEqBI,W,CAAqB,CACzC,GAAMZ,WAAY,KAAKA,SAAvB,CAEA,GACEA,WAAa,IAAb,EACA,CAAC,KAAKU,iBADN,EAEA,KAAKF,oBAHP,CAIE,CAEA,OACD,CAED,GAAI,KAAKC,cAAL,GAAwB,CAAC,CAA7B,CAAgC,CAE9B,KAAKA,cAAL,CAAsBG,sDAAtB,CAEA,GAAI,KAAKV,SAAL,GAAmB,KAAKC,SAA5B,CAAuC,CAErC,KAAKD,SAAL,CAAiBF,UAAUa,KAA3B,CACD,CAHD,IAGO,CAEL,KAAKC,WAAL,CAAiB,KAAKZ,SAAtB,EACD,CACD,KAAKC,SAAL,CAAiBH,UAAUa,KAA3B,CACD,CAED,GAAMA,OACJ,KAAKX,SAAL,CACA,KAAKE,QAAL,EACG,EAAI,KAAKC,YADZ,GAEG,EACCU,KAAKC,GAAL,CACE,EAAE,EAAI,KAAKX,YAAX,GAA4BO,YAAc,KAAKH,cAA/C,CADF,CAHJ,CAFF,CASA,KAAKK,WAAL,CAAiBD,KAAjB,EAEA,GAAIE,KAAKE,GAAL,CAAS,KAAKd,SAAL,CAAiBU,KAA1B,EAAmC,GAAvC,CAA4C,CAC1C,GAAI,KAAKP,UAAL,GAAoB,CAAC,CAArB,EAA0B,KAAKC,WAAL,CAAmB,KAAKD,UAAtD,CAAkE,CAChE,KAAKG,cAAL,CAAsB,CAAC,CAAvB,CACA,KAAKF,WAAL,GACD,CAHD,IAGO,CACL,KAAKC,oBAAL,CAA4B,IAA5B,CACA,OACD,CACF,CAED,KAAKL,SAAL,CAAiBU,KAAjB,CACD,C,gDAEWK,W,CAAqB,CAC/B,GAAMlB,WAAY,KAAKA,SAAvB,CACA,GAAIA,SAAJ,CAAe,CACbA,UAAUa,KAAV,CAAkBK,WAAlB,CACAlB,UAAUmB,cAAV,GACD,CACF,C,iDAGYtB,iB","file":"RCTDecayAnimation.js","sourcesContent":["/**\n * @providesModule RCTDecayAnimation\n * @flow\n */\n\nimport type { Config } from \"RCTNativeAnimatedModule\";\nimport type { RCTAnimationDriver } from \"RCTAnimationDriver\";\nimport type RCTValueAnimatedNode from \"RCTValueAnimatedNode\";\n\nimport { RCTSingleFrameInterval } from \"RCTAnimationDriver\";\n\nclass RCTDecayAnimation implements RCTAnimationDriver {\n  animationId: number;\n  valueNode: RCTValueAnimatedNode;\n  animationHasBegun: boolean;\n  animationHasFinished: boolean;\n\n  velocity: number;\n  deceleration: number;\n  frameStartTime: number;\n  fromValue: number;\n  lastValue: number;\n  iterations: number;\n  currentLoop: number;\n  callback: Function;\n\n  constructor(\n    animationId: number,\n    config: Config,\n    valueNode: RCTValueAnimatedNode,\n    callback: Function\n  ) {\n    this.animationId = animationId;\n    this.fromValue = 0;\n    this.lastValue = 0;\n    this.valueNode = valueNode;\n    this.callback = callback;\n    this.velocity = config.velocity;\n    this.deceleration = config.deceleration;\n    this.iterations = config.iterations != null ? config.iterations : 1;\n    this.currentLoop = 1;\n    this.animationHasFinished = this.iterations === 0;\n    return this;\n  }\n\n  startAnimation() {\n    this.frameStartTime = -1;\n    this.animationHasBegun = true;\n  }\n\n  stopAnimation() {\n    // this.valueNode = null;\n    if (this.callback) {\n      this.callback({\n        finished: this.animationHasFinished\n      });\n    }\n  }\n\n  stepAnimationWithTime(currentTime: number) {\n    const valueNode = this.valueNode;\n\n    if (\n      valueNode == null ||\n      !this.animationHasBegun ||\n      this.animationHasFinished\n    ) {\n      // Animation has not begun or animation has already finished.\n      return;\n    }\n\n    if (this.frameStartTime === -1) {\n      // Since this is the first animation step, consider the start to be on the previous frame.\n      this.frameStartTime = currentTime - RCTSingleFrameInterval;\n\n      if (this.fromValue === this.lastValue) {\n        // First iteration, assign _fromValue based on _valueNode.\n        this.fromValue = valueNode.value;\n      } else {\n        // Not the first iteration, reset _valueNode based on _fromValue.\n        this.updateValue(this.fromValue);\n      }\n      this.lastValue = valueNode.value;\n    }\n\n    const value =\n      this.fromValue +\n      this.velocity /\n        (1 - this.deceleration) *\n        (1 -\n          Math.exp(\n            -(1 - this.deceleration) * (currentTime - this.frameStartTime)\n          ));\n\n    this.updateValue(value);\n\n    if (Math.abs(this.lastValue - value) < 0.1) {\n      if (this.iterations === -1 || this.currentLoop < this.iterations) {\n        this.frameStartTime = -1;\n        this.currentLoop++;\n      } else {\n        this.animationHasFinished = true;\n        return;\n      }\n    }\n\n    this.lastValue = value;\n  }\n\n  updateValue(outputValue: number) {\n    const valueNode = this.valueNode;\n    if (valueNode) {\n      valueNode.value = outputValue;\n      valueNode.setNeedsUpdate();\n    }\n  }\n}\n\nexport default RCTDecayAnimation;\n"]}