{"version":3,"sources":["../../../../ReactDom/modules/NativeAnimation/Drivers/RCTSpringAnimation.js"],"names":["MAX_DELTA_TIME","RCTSpringAnimation","animationId","config","valueNode","callback","iterations","toValue","fromValue","value","lastPosition","overshootClamping","restDisplacementThreshold","restSpeedThreshold","stiffness","damping","mass","initialVelocity","lastVelocity","animationHasFinished","currentLoop","animationStartTime","animationCurrentTime","animationHasBegun","finished","currentTime","deltaTime","_t","curDeltaTime","Math","min","c","m","k","v0","zeta","sqrt","omega0","omega1","x0","position","velocity","envelope","exp","sin","cos","onUpdate","isOvershooting","isVelocity","abs","isDisplacement","outputValue","setNeedsUpdate"],"mappings":"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","file":"RCTSpringAnimation.js","sourcesContent":["/**\n * @providesModule RCTSpringAnimation\n * @flow\n */\n\nimport type { Config } from \"RCTNativeAnimatedModule\";\nimport type { RCTAnimationDriver } from \"RCTAnimationDriver\";\nimport type RCTValueAnimatedNode from \"RCTValueAnimatedNode\";\n\nimport { RCTSingleFrameInterval } from \"RCTAnimationDriver\";\n\nconst MAX_DELTA_TIME: number = 0.064;\n\nclass RCTSpringAnimation implements RCTAnimationDriver {\n  animationId: number;\n  valueNode: RCTValueAnimatedNode;\n  animationHasBegun: boolean;\n  animationHasFinished: boolean;\n\n  toValue: number;\n  fromValue: number;\n  overshootClamping: boolean;\n  restDisplacementThreshold: number;\n  restSpeedThreshold: number;\n  stiffness: number;\n  damping: number;\n  mass: number;\n  initialVelocity: number;\n  animationStartTime: number;\n  animationCurrentTime: number;\n  callback: ?Function;\n\n  lastPosition: number;\n  lastVelocity: number;\n\n  iterations: number;\n  currentLoop: number;\n\n  _t: number;\n\n  constructor(\n    animationId: number,\n    config: Config,\n    valueNode: RCTValueAnimatedNode,\n    callback: ?Function\n  ) {\n    const iterations = config.iterations != null ? config.iterations : 1;\n\n    this.animationId = animationId;\n    this.toValue = config.toValue;\n    this.fromValue = valueNode.value;\n    this.lastPosition = 0;\n    this.valueNode = valueNode;\n    this.overshootClamping = config.overshootClamping;\n    this.restDisplacementThreshold = config.restDisplacementThreshold;\n    this.restSpeedThreshold = config.restSpeedThreshold;\n    this.stiffness = config.stiffness;\n    this.damping = config.damping;\n    this.mass = config.mass;\n    this.initialVelocity = config.initialVelocity;\n    this.callback = callback;\n\n    this.lastPosition = this.fromValue;\n    this.lastVelocity = this.initialVelocity;\n\n    this.animationHasFinished = iterations === 0;\n    this.iterations = iterations;\n    this.currentLoop = 1;\n    return this;\n  }\n\n  startAnimation() {\n    this.animationStartTime = this.animationCurrentTime = -1;\n    this.animationHasBegun = true;\n  }\n\n  stopAnimation() {\n    if (this.callback) {\n      this.callback({ finished: this.animationHasFinished });\n    }\n  }\n\n  stepAnimationWithTime(currentTime: number) {\n    if (!this.animationHasBegun || this.animationHasFinished) {\n      return;\n    }\n\n    let deltaTime;\n    if (this.animationStartTime === -1) {\n      this._t = 0.0;\n      this.animationStartTime = currentTime;\n      deltaTime = 0.0;\n    } else {\n      // need to adjust the delta time to be in seconds\n      const curDeltaTime = (currentTime - this.animationCurrentTime) / 1000;\n      // Handle frame drops, and only advance dt by a max of MAX_DELTA_TIME\n      deltaTime = Math.min(MAX_DELTA_TIME, curDeltaTime);\n      this._t += deltaTime;\n    }\n\n    // store the timestamp\n    this.animationCurrentTime = currentTime;\n\n    const c = this.damping;\n    const m = this.mass;\n    const k = this.stiffness;\n    const v0 = -this.initialVelocity;\n\n    const zeta = c / (2 * Math.sqrt(k * m)); // damping ratio\n    const omega0 = Math.sqrt(k / m); // undamped angular frequency of the oscillator (rad/ms)\n    const omega1 = omega0 * Math.sqrt(1.0 - zeta * zeta); // exponential decay\n    const x0 = this.toValue - this.fromValue; // calculate the oscillation from x0 = 1 to x = 0\n\n    let position;\n    let velocity;\n\n    if (zeta < 1) {\n      // Under damped\n      const envelope = Math.exp(-zeta * omega0 * this._t);\n      position =\n        this.toValue -\n        envelope *\n          ((v0 + zeta * omega0 * x0) / omega1 * Math.sin(omega1 * this._t) +\n            x0 * Math.cos(omega1 * this._t));\n      // This looks crazy -- it's actually just the derivative of the\n      // oscillation function\n      velocity =\n        zeta *\n          omega0 *\n          envelope *\n          (Math.sin(omega1 * this._t) * (v0 + zeta * omega0 * x0) / omega1 +\n            x0 * Math.cos(omega1 * this._t)) -\n        envelope *\n          (Math.cos(omega1 * this._t) * (v0 + zeta * omega0 * x0) -\n            omega1 * x0 * Math.sin(omega1 * this._t));\n    } else {\n      // Critically damped\n      const envelope = Math.exp(-omega0 * this._t);\n      position = this.toValue - envelope * (x0 + (v0 + omega0 * x0) * this._t);\n      velocity =\n        envelope *\n        (v0 * (this._t * omega0 - 1) + this._t * x0 * (omega0 * omega0));\n    }\n\n    this.lastPosition = position;\n    this.lastVelocity = velocity;\n\n    this.onUpdate(position);\n\n    // Conditions for stopping the spring animation\n    let isOvershooting = false;\n    if (this.overshootClamping && this.stiffness !== 0) {\n      if (this.fromValue < this.toValue) {\n        isOvershooting = position > this.toValue;\n      } else {\n        isOvershooting = position < this.toValue;\n      }\n    }\n\n    let isVelocity = Math.abs(velocity) <= this.restSpeedThreshold;\n    let isDisplacement = true;\n    if (this.stiffness !== 0) {\n      isDisplacement =\n        Math.abs(this.toValue - position) <= this.restDisplacementThreshold;\n    }\n\n    if (isOvershooting || (isVelocity && isDisplacement)) {\n      if (this.stiffness !== 0) {\n        // Ensure that we end up with a round value\n        if (this.animationHasFinished) {\n          return;\n        }\n        this.onUpdate(this.toValue);\n      }\n\n      if (this.iterations === -1 || this.currentLoop < this.iterations) {\n        this.lastPosition = this.fromValue;\n        this.lastVelocity = this.initialVelocity;\n        this.animationStartTime = -1;\n        this.currentLoop++;\n        this.onUpdate(this.fromValue);\n      } else {\n        this.animationHasFinished = true;\n      }\n    }\n  }\n\n  onUpdate(outputValue: number) {\n    this.valueNode.value = outputValue;\n    this.valueNode.setNeedsUpdate();\n  }\n}\n\nexport default RCTSpringAnimation;\n"]}