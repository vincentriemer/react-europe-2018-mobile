{"version":3,"sources":["../../../ReactDom/views/Text/RCTShadowText.js"],"names":["YG","TEXT_SHADOW_STYLE_PROPS","TEXT_PX_PROPS","textMeasurementContainer","document","createElement","id","style","visibility","pointerEvents","contain","body","appendChild","module","exports","Constants","RCTShadowView","RCTShadowRawText","RCTShadowText","yogaNode","setMeasureFunc","width","widthMeasureMode","height","heightMeasureMode","measure","props","textChildren","textDirty","numberOfLines","forEach","shadowPropName","Object","defineProperty","configurable","get","set","value","includes","markTextDirty","markDirty","reactSuperview","testDomElement","testDOMElement","firstChild","removeChild","clearTestDomElement","whiteSpace","measureMode","exactly","undefined","maxWidth","maxHeight","getTestTree","getBoundingClientRect","measuredWidth","measuredHeight","remove","_testDOMElement","Math","ceil","_testTree","spanWrapper","child","text","length","textLines","split","i","currentLine","insertAdjacentText","insertAdjacentElement","subview","index","splice","filter","s","parentNode","_numberOfLines","domElement","position","display"],"mappings":"+0BAKA,iC,GAAYA,G,mCACZ,wC,yCACA,kD,mDACA,0DAOA,kD,4DACA,qD,+XAEA,GAAMC,yBAA0B,CAC9B,YAD8B,CAE9B,UAF8B,CAG9B,WAH8B,CAI9B,YAJ8B,CAK9B,YAL8B,CAM9B,eAN8B,CAAhC,CASA,GAAMC,eAAgB,CAAC,YAAD,CAAtB,CAEA,GAAMC,0BAA2BC,SAASC,aAAT,CAAuB,KAAvB,CAAjC,CACAF,yBAAyBG,EAAzB,CAA8B,kBAA9B,CACA,sBAAcH,yBAAyBI,KAAvC,CAA8C,CAC5CC,WAAY,QADgC,CAE5CC,cAAe,MAF6B,CAG5CC,QAAS,UAHmC,CAA9C,EAKAN,SAASO,IAAT,EAAiBP,SAASO,IAAT,CAAcC,WAAd,CAA0BT,wBAA1B,CAAjB,CAEAU,OAAOC,OAAP,CAAkB,yPAjCNd,EAiCM,oCACRe,SADQ,MACRA,SADQ,oFAEVC,aAFU,qGAGVC,gBAHU,eAKVC,aALU,iFAsBd,wBAAc,qLAIZ,MAAKC,QAAL,CAAcC,cAAd,CACE,SAACC,KAAD,CAAQC,gBAAR,CAA0BC,MAA1B,CAAkCC,iBAAlC,QACE,OAAKC,OAAL,CAAaJ,KAAb,CAAoBC,gBAApB,CAAsCC,MAAtC,CAA8CC,iBAA9C,CADF,EADF,EAKA,MAAKE,KAAL,CAAa,EAAb,CACA,MAAKC,YAAL,CAAoB,EAApB,CACA,MAAKC,SAAL,CAAiB,IAAjB,CACA,MAAKC,aAAL,CAAqB,CAArB,CAEA5B,wBAAwB6B,OAAxB,CAAgC,SAACC,cAAD,CAA4B,CAC1DC,OAAOC,cAAP,OAA4BF,cAA5B,CAA4C,CAC1CG,aAAc,IAD4B,CAE1CC,IAAK,qBAAM,OAAKT,KAAL,CAAWK,cAAX,CAAN,EAFqC,CAG1CK,IAAK,aAACC,KAAD,CAAW,CACd,GAAIA,OAAS,IAAb,CAAmB,CACjB,MAAKX,KAAL,CAAWK,cAAX,EAA6B7B,cAAcoC,QAAd,CAC3BP,cAD2B,EAGtBM,KAHsB,MAIzBA,KAJJ,CAKD,CAND,IAMO,CACL,MAAKX,KAAL,CAAWK,cAAX,EAA6B,SAA7B,CACD,CACD,MAAKQ,aAAL,GACA,OACD,CAfyC,CAA5C,EAkBA,MAAKR,cAAL,EAAuB,IAAvB,CACD,CApBD,EAdY,aAmCb,CAzDa,4FAwFE,CACd,KAAKZ,QAAL,CAAcqB,SAAd,GACA,KAAKZ,SAAL,CAAiB,IAAjB,CACA,GAAI,KAAKa,cAAL,WAA+BvB,cAAnC,CAAkD,CAChD,KAAKuB,cAAL,CAAoBF,aAApB,GACD,CACF,CA9Fa,iEAgGQ,CACpB,GAAMG,gBAAiB,KAAKC,cAA5B,CACA,MAAOD,eAAeE,UAAtB,CAAkC,CAChCF,eAAeG,WAAf,CAA2BH,eAAeE,UAA1C,EACD,CACF,CArGa,wCAiHZvB,KAjHY,CAkHZC,gBAlHY,CAmHZC,MAnHY,CAoHZC,iBApHY,CAqHuB,CACnC,KAAKsB,mBAAL,GAEA,GAAMC,YAAa,KAAKlB,aAAL,GAAuB,CAAvB,CAA2B,QAA3B,CAAsC,UAAzD,CAEA,GACEP,mBAAqBP,UAAUiC,WAAV,CAAsBC,OAA3C,EACAzB,oBAAsBT,UAAUiC,WAAV,CAAsBC,OAF9C,CAGE,CACA,GAAI3B,mBAAqBP,UAAUiC,WAAV,CAAsBE,SAA/C,CAA0D,CACxD,sBAAc,KAAKP,cAAL,CAAoBpC,KAAlC,CAAyC,CACvC4C,SAAa9B,KAAb,KADuC,CAEvC+B,UAAW,MAF4B,CAGvCL,qBAHuC,CAAzC,EAKD,CAND,IAMO,CACL,sBAAc,KAAKJ,cAAL,CAAoBpC,KAAlC,CAAyC,CACvC4C,SAAU,MAD6B,CAEvCC,UAAc7B,MAAd,KAFuC,CAGvCwB,qBAHuC,CAAzC,EAKD,CACF,CAjBD,IAiBO,CACL,MAAO,CACL1B,MAAOA,OAAS,CADX,CAELE,OAAQA,QAAU,CAFb,CAAP,CAID,CAED,KAAKoB,cAAL,CAAoB/B,WAApB,CAAgC,KAAKyC,WAAL,EAAhC,EA7BmC,0BAkC/B,KAAKV,cAAL,CAAoBW,qBAApB,EAlC+B,CAgC1BC,aAhC0B,uBAgCjClC,KAhCiC,CAiCzBmC,cAjCyB,uBAiCjCjC,MAjCiC,CAoCnC,KAAKoB,cAAL,CAAoBc,MAApB,GACA,KAAKC,eAAL,CAAuB,IAAvB,CAEA,MAAO,CACLrC,MAAOsC,KAAKC,IAAL,CAAUL,aAAV,CADF,CAELhC,OAAQoC,KAAKC,IAAL,CAAUJ,cAAV,CAFH,CAAP,CAID,CAhKa,iDAkKa,CACzB,GAAI,CAAC,KAAK5B,SAAV,CAAqB,CACnB,wBACE,KAAKiC,SADP,CAEE,mEAFF,EAIA,MAAO,MAAKA,SAAZ,CACD,CAED,GAAMC,aAAc1D,SAASC,aAAT,CAAuB,MAAvB,CAApB,CACA,sBAAcyD,YAAYvD,KAA1B,CAAiC,KAAKmB,KAAtC,EAEA,KAAKC,YAAL,CAAkBG,OAAlB,CAA0B,SAACiC,KAAD,CAAW,CACnC,GAAIA,gBAAiB9C,iBAAjB,EAAqC8C,MAAMC,IAAN,CAAWC,MAApD,CAA4D,CAE1D,GAAMC,WAAYH,MAAMC,IAAN,CAAWG,KAAX,CAAiB,OAAjB,CAAlB,CACA,IAAK,GAAIC,GAAI,CAAb,CAAgBA,EAAIF,UAAUD,MAA9B,CAAsCG,GAAtC,CAA2C,CACzC,GAAMC,aAAcH,UAAUE,CAAV,CAApB,CACAN,YAAYQ,kBAAZ,CAA+B,WAA/B,CAA4CD,WAA5C,EAEA,GAAID,EAAIF,UAAUD,MAAV,CAAmB,CAA3B,CAA8B,CAC5BH,YAAYS,qBAAZ,CACE,WADF,CAEEnE,SAASC,aAAT,CAAuB,IAAvB,CAFF,EAID,CACF,CACF,CAdD,IAcO,IAAI0D,gBAAiB7C,cAArB,CAAoC,CACzC4C,YAAYS,qBAAZ,CAAkC,WAAlC,CAA+CR,MAAMV,WAAN,EAA/C,EACD,CACF,CAlBD,EAoBA,KAAKQ,SAAL,CAAiBC,WAAjB,CACA,KAAKlC,SAAL,CAAiB,KAAjB,CAEA,MAAO,MAAKiC,SAAZ,CACD,CAtMa,4EAyMZW,OAzMY,CA0MZC,KA1MY,CA2MZ,CACAD,QAAQ/B,cAAR,CAAyB,IAAzB,CACA,KAAKd,YAAL,CAAkB+C,MAAlB,CAAyBD,KAAzB,CAAgC,CAAhC,CAAmCD,OAAnC,EACA,KAAKjC,aAAL,GACD,CA/Ma,8DAiNKiC,OAjNL,CAiNgD,CAC5DA,QAAQ/B,cAAR,CAAyBS,SAAzB,CACA,KAAKvB,YAAL,CAAoB,KAAKA,YAAL,CAAkBgD,MAAlB,CAAyB,SAACC,CAAD,QAAOA,KAAMJ,OAAb,EAAzB,CAApB,CACA,KAAKjC,aAAL,GACD,CArNa,qCAuNN,CACN,6HACA,GAAI,KAAKmB,eAAT,CAA0B,CACxB,KAAKA,eAAL,CAAqBmB,UAArB,EACE,KAAKnB,eAAL,CAAqBmB,UAArB,CAAgChC,WAAhC,CAA4C,KAAKa,eAAjD,CADF,CAED,CACF,CA7Na,yCA2Dc,CAC1B,MAAO,MAAKoB,cAAZ,CACD,CA7Da,kBA+DIzC,KA/DJ,CA+DmB,CAC/B,KAAKyC,cAAL,CAAsBzC,KAAtB,CACA,KAAKE,aAAL,GACD,CAlEa,0CAoEoB,CAChC,GAAI,KAAKmB,eAAL,EAAwB,IAA5B,CAAkC,CAEhC,GAAMqB,YAAa3E,SAASC,aAAT,CAAuB,KAAvB,CAAnB,CACA0E,WAAWzE,EAAX,CAAgB,oBAAhB,CACA,sBAAcyE,WAAWxE,KAAzB,CAAgC,CAC9ByE,SAAU,UADoB,CAE9BxE,WAAY,QAFkB,CAG9B4C,UAAW,MAHmB,CAI9BD,SAAU,MAJoB,CAK9BJ,WAAY,QALkB,CAM9BkC,QAAS,cANqB,CAO9BvE,QAAS,cAPqB,CAAhC,EASAP,yBAAyBS,WAAzB,CAAqCmE,UAArC,EACA,KAAKrB,eAAL,CAAuBqB,UAAvB,CACD,CACD,MAAO,MAAKrB,eAAZ,CACD,CAtFa,2BAKY1C,aALZ,kCAgOTE,aAhOS,6DAAD,EAAjB","file":"RCTShadowText.js","sourcesContent":["/**\n * @providesModule RCTShadowText\n * @flow\n */\n\nimport * as YG from \"yoga-dom\";\nimport guid from \"Guid\";\nimport invariant from \"Invariant\";\nimport {\n  defaultFontStack,\n  defaultFontSize,\n  defaults as TextDefaults\n} from \"RCTSharedTextValues\";\n\nimport _Yoga from \"yoga-dom\";\nimport _RCTShadowView from \"RCTShadowView\";\nimport _RCTShadowRawText from \"RCTShadowRawText\";\n\nconst TEXT_SHADOW_STYLE_PROPS = [\n  \"fontFamily\",\n  \"fontSize\",\n  \"fontStyle\",\n  \"fontWeight\",\n  \"lineHeight\",\n  \"letterSpacing\"\n];\n\nconst TEXT_PX_PROPS = [\"lineHeight\"];\n\nconst textMeasurementContainer = document.createElement(\"div\");\ntextMeasurementContainer.id = \"text-measurement\";\nObject.assign(textMeasurementContainer.style, {\n  visibility: \"hidden\",\n  pointerEvents: \"none\",\n  contain: \"contents\"\n});\ndocument.body && document.body.appendChild(textMeasurementContainer);\n\nmodule.exports = (async () => {\n  const { Constants } = await _Yoga;\n  const RCTShadowView = await _RCTShadowView;\n  const RCTShadowRawText = await _RCTShadowRawText;\n\n  class RCTShadowText extends RCTShadowView {\n    previousWidth: number;\n    previousHeight: number;\n    textChildren: Array<RCTShadowText | RCTShadowRawText>;\n    textDirty: boolean;\n    props: { [string]: any };\n\n    fontFamily: ?string;\n    fontSize: ?string;\n    fontStyle: ?string;\n    fontWeight: ?string;\n    lineHeight: ?string;\n\n    _testTree: ?HTMLElement;\n    _testDOMElement: ?HTMLElement;\n    _numberOfLines: number;\n\n    constructor() {\n      super();\n\n      // custom measure function for the flexbox layout\n      this.yogaNode.setMeasureFunc(\n        (width, widthMeasureMode, height, heightMeasureMode) =>\n          this.measure(width, widthMeasureMode, height, heightMeasureMode)\n      );\n\n      this.props = {};\n      this.textChildren = [];\n      this.textDirty = true;\n      this.numberOfLines = 0;\n\n      TEXT_SHADOW_STYLE_PROPS.forEach((shadowPropName: string) => {\n        Object.defineProperty(this, shadowPropName, {\n          configurable: true,\n          get: () => this.props[shadowPropName],\n          set: (value) => {\n            if (value != null) {\n              this.props[shadowPropName] = TEXT_PX_PROPS.includes(\n                shadowPropName\n              )\n                ? `${value}px`\n                : value;\n            } else {\n              this.props[shadowPropName] = \"inherit\";\n            }\n            this.markTextDirty();\n            return;\n          }\n        });\n        // $FlowFixMe\n        this[shadowPropName] = null;\n      });\n    }\n\n    get numberOfLines(): number {\n      return this._numberOfLines;\n    }\n\n    set numberOfLines(value: number) {\n      this._numberOfLines = value;\n      this.markTextDirty();\n    }\n\n    get testDOMElement(): HTMLElement {\n      if (this._testDOMElement == null) {\n        // create dom node for measuring text\n        const domElement = document.createElement(\"div\");\n        domElement.id = guid();\n        Object.assign(domElement.style, {\n          position: \"absolute\",\n          visibility: \"hidden\",\n          maxHeight: \"auto\",\n          maxWidth: \"auto\",\n          whiteSpace: \"nowrap\",\n          display: \"inline-block\",\n          contain: \"layout paint\"\n        });\n        textMeasurementContainer.appendChild(domElement);\n        this._testDOMElement = domElement;\n      }\n      return this._testDOMElement;\n    }\n\n    markTextDirty() {\n      this.yogaNode.markDirty();\n      this.textDirty = true;\n      if (this.reactSuperview instanceof RCTShadowText) {\n        this.reactSuperview.markTextDirty();\n      }\n    }\n\n    clearTestDomElement() {\n      const testDomElement = this.testDOMElement;\n      while (testDomElement.firstChild) {\n        testDomElement.removeChild(testDomElement.firstChild);\n      }\n    }\n\n    /**\n     * Measure the dimensions of the text associated\n     * callback for css-layout\n     * @param: width - input width extents\n     * @param: widthMeasureMode - mode to constrain width CSS_MEASURE_MODE_EXACTLY, CSS_MEASURE_MODE_UNDEFINED\n     * @param: height - input height extents\n     * @param: heightMeasureMode - mode to constrain height CSS_MEASURE_MODE_EXACTLY, CSS_MEASURE_MODE_UNDEFINED\n     * @return: object containing measured width and height\n     */\n    measure(\n      width: number,\n      widthMeasureMode: *,\n      height: number,\n      heightMeasureMode: *\n    ): { width: number, height: number } {\n      this.clearTestDomElement();\n\n      const whiteSpace = this.numberOfLines === 1 ? \"nowrap\" : \"pre-wrap\";\n\n      if (\n        widthMeasureMode !== Constants.measureMode.exactly ||\n        heightMeasureMode !== Constants.measureMode.exactly\n      ) {\n        if (widthMeasureMode !== Constants.measureMode.undefined) {\n          Object.assign(this.testDOMElement.style, {\n            maxWidth: `${width}px`,\n            maxHeight: \"auto\",\n            whiteSpace\n          });\n        } else {\n          Object.assign(this.testDOMElement.style, {\n            maxWidth: \"auto\",\n            maxHeight: `${height}px`,\n            whiteSpace\n          });\n        }\n      } else {\n        return {\n          width: width || 0,\n          height: height || 0\n        };\n      }\n\n      this.testDOMElement.appendChild(this.getTestTree());\n\n      const {\n        width: measuredWidth,\n        height: measuredHeight\n      } = this.testDOMElement.getBoundingClientRect();\n\n      this.testDOMElement.remove();\n      this._testDOMElement = null;\n\n      return {\n        width: Math.ceil(measuredWidth),\n        height: Math.ceil(measuredHeight)\n      };\n    }\n\n    getTestTree(): HTMLElement {\n      if (!this.textDirty) {\n        invariant(\n          this._testTree,\n          \"ShadowText is not marked as dirty but there is no cached testTree\"\n        );\n        return this._testTree;\n      }\n\n      const spanWrapper = document.createElement(\"span\");\n      Object.assign(spanWrapper.style, this.props);\n\n      this.textChildren.forEach((child) => {\n        if (child instanceof RCTShadowRawText && child.text.length) {\n          // Split text by newline and insert breaks manually as insertAdjacentText does not respect newlines\n          const textLines = child.text.split(/\\r?\\n/);\n          for (let i = 0; i < textLines.length; i++) {\n            const currentLine = textLines[i];\n            spanWrapper.insertAdjacentText(\"beforeend\", currentLine);\n\n            if (i < textLines.length - 1) {\n              spanWrapper.insertAdjacentElement(\n                \"beforeend\",\n                document.createElement(\"br\")\n              );\n            }\n          }\n        } else if (child instanceof RCTShadowText) {\n          spanWrapper.insertAdjacentElement(\"beforeend\", child.getTestTree());\n        }\n      });\n\n      this._testTree = spanWrapper;\n      this.textDirty = false;\n\n      return this._testTree;\n    }\n\n    insertReactSubviewAtIndex(\n      subview: RCTShadowText | RCTShadowRawText,\n      index: number\n    ) {\n      subview.reactSuperview = this;\n      this.textChildren.splice(index, 0, subview);\n      this.markTextDirty();\n    }\n\n    removeReactSubview(subview: RCTShadowText | RCTShadowRawText) {\n      subview.reactSuperview = undefined;\n      this.textChildren = this.textChildren.filter((s) => s !== subview);\n      this.markTextDirty();\n    }\n\n    purge() {\n      super.purge();\n      if (this._testDOMElement) {\n        this._testDOMElement.parentNode &&\n          this._testDOMElement.parentNode.removeChild(this._testDOMElement);\n      }\n    }\n  }\n\n  return RCTShadowText;\n})();\n"]}