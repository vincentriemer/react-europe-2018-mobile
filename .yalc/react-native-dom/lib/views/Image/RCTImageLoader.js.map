{"version":3,"sources":["../../../ReactDom/views/Image/RCTImageLoader.js"],"names":["RCTImageLoader","bridge","imageCache","url","loadPromise","Promise","resolve","reject","image","Image","startsWith","blob","blobManager","resolveURL","URL","createObjectURL","onload","onerror","src","existingImage","loadImage","getImagePromise","then","width","height"],"mappings":"mUAKA,mD,yIAQMA,e,OADL,iCAAkB,gBAAlB,C,wBAMC,wBAAYC,MAAZ,CAA+B,mDAC7B,KAAKA,MAAL,CAAcA,MAAd,CACA,KAAKC,UAAL,CAAkB,EAAlB,CACD,C,oFAESC,G,CAA6B,gBACrC,GAAMC,aAAc,GAAIC,QAAJ,CAAY,SAACC,OAAD,CAAUC,MAAV,CAAqB,CACnD,GAAMC,OAAQ,GAAIC,MAAJ,EAAd,CAGA,GAAIN,IAAIO,UAAJ,CAAe,OAAf,CAAJ,CAA6B,MAAOJ,SAAQE,KAAR,CAAP,CAE7B,GAAIL,IAAIO,UAAJ,CAAe,OAAf,CAAJ,CAA6B,CAC3B,GAAMC,MAAO,MAAKV,MAAL,CAAYW,WAAZ,CAAwBC,UAAxB,CAAmCV,GAAnC,CAAb,CACAA,IAAMW,IAAIC,eAAJ,CAAoBJ,IAApB,CAAN,CACD,CAEDH,MAAMQ,MAAN,CAAe,iBAAMV,SAAQE,KAAR,CAAN,EAAf,CACAA,MAAMS,OAAN,CAAgB,iBAAMV,SAAN,EAAhB,CAEAC,MAAMU,GAAN,CAAYf,GAAZ,CACD,CAfmB,CAApB,CAiBA,KAAKD,UAAL,CAAgBC,GAAhB,EAAuBC,WAAvB,CAEA,MAAOA,YAAP,CACD,C,wDAEeD,G,CAA6B,CAC3C,GAAMgB,eAAgB,KAAKjB,UAAL,CAAgBC,GAAhB,CAAtB,CACA,GAAIgB,eAAiB,IAArB,CAA2B,CACzB,MAAOA,cAAP,CACD,CAFD,IAEO,CACL,MAAO,MAAKC,SAAL,CAAejB,GAAf,CAAP,CACD,CACF,C,wEAEuBA,G,CAA6B,CACnD,MAAO,MAAKkB,eAAL,CAAqBlB,GAArB,CAAP,CACD,C,4EAEyBA,G,CAA4B,CACpD,MAAO,MAAKkB,eAAL,CAAqBlB,GAArB,EAA0BmB,IAA1B,CAA+B,SAACd,KAAD,CAAkB,CACtD,MAAO,CACLe,MAAOf,MAAMe,KADR,CAELC,OAAQhB,MAAMgB,MAFT,CAAP,CAID,CALM,CAAP,CAMD,C,wDAGYxB,c","file":"RCTImageLoader.js","sourcesContent":["/**\n * @providesModule RCTImageLoader\n * @flow\n */\n\nimport RCTBridge, {\n  RCT_EXPORT_MODULE,\n  RCT_EXPORT_METHOD,\n  RCTFunctionTypeNormal,\n  RCTFunctionTypePromise\n} from \"RCTBridge\";\n\n@RCT_EXPORT_MODULE(\"RCTImageLoader\")\nclass RCTImageLoader {\n  bridge: RCTBridge;\n\n  imageCache: { [cacheKey: string]: Promise<Image> };\n\n  constructor(bridge: RCTBridge) {\n    this.bridge = bridge;\n    this.imageCache = {};\n  }\n\n  loadImage(url: string): Promise<Image> {\n    const loadPromise = new Promise((resolve, reject) => {\n      const image = new Image();\n\n      // skip loading on data uris\n      if (url.startsWith(\"data:\")) return resolve(image);\n\n      if (url.startsWith(\"blob:\")) {\n        const blob = this.bridge.blobManager.resolveURL(url);\n        url = URL.createObjectURL(blob);\n      }\n\n      image.onload = () => resolve(image);\n      image.onerror = () => reject();\n\n      image.src = url;\n    });\n\n    this.imageCache[url] = loadPromise;\n\n    return loadPromise;\n  }\n\n  getImagePromise(url: string): Promise<Image> {\n    const existingImage = this.imageCache[url];\n    if (existingImage != null) {\n      return existingImage;\n    } else {\n      return this.loadImage(url);\n    }\n  }\n\n  loadImageWithURLRequest(url: string): Promise<Image> {\n    return this.getImagePromise(url);\n  }\n\n  getImageSizeForURLRequest(url: string): Promise<Size> {\n    return this.getImagePromise(url).then((image: Image) => {\n      return {\n        width: image.width,\n        height: image.height\n      };\n    });\n  }\n}\n\nexport default RCTImageLoader;\n"]}