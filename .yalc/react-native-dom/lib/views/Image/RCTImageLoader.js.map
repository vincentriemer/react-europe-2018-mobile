{"version":3,"sources":["../../../ReactDom/views/Image/RCTImageLoader.js"],"names":["RCTImageLoader","bridge","imageCache","url","loadPromise","Promise","resolve","reject","image","Image","src","startsWith","decode","then","catch","err","onload","onerror","existingImage","loadImage","getImagePromise","width","height"],"mappings":"mUAKA,mD,yIAQMA,e,OADL,iCAAkB,gBAAlB,C,wBAMC,wBAAYC,MAAZ,CAA+B,mDAC7B,KAAKA,MAAL,CAAcA,MAAd,CACA,KAAKC,UAAL,CAAkB,EAAlB,CACD,C,oFAESC,G,CAA6B,CACrC,GAAMC,aAAc,GAAIC,QAAJ,CAAY,SAACC,OAAD,CAAUC,MAAV,CAAqB,CACnD,GAAMC,OAAQ,GAAIC,MAAJ,EAAd,CACAD,MAAME,GAAN,CAAYP,GAAZ,CAGA,GAAIA,IAAIQ,UAAJ,CAAe,OAAf,CAAJ,CAA6B,MAAOL,SAAQE,KAAR,CAAP,CAG7B,GAAI,MAAOA,OAAMI,MAAb,GAAwB,UAA5B,CAAwC,CACtCJ,MACGI,MADH,GAEGC,IAFH,CAEQ,UAAM,CACVP,QAAQE,KAAR,EACD,CAJH,EAKGM,KALH,CAKS,SAACC,GAAD,CAAS,CACdR,OAAOQ,GAAP,EACD,CAPH,EAQD,CATD,IASO,CACLP,MAAMQ,MAAN,CAAe,iBAAMV,SAAQE,KAAR,CAAN,EAAf,CACAA,MAAMS,OAAN,CAAgB,iBAAMV,SAAN,EAAhB,CACD,CACF,CArBmB,CAApB,CAuBA,KAAKL,UAAL,CAAgBC,GAAhB,EAAuBC,WAAvB,CAEA,MAAOA,YAAP,CACD,C,wDAEeD,G,CAA6B,CAC3C,GAAMe,eAAgB,KAAKhB,UAAL,CAAgBC,GAAhB,CAAtB,CACA,GAAIe,eAAiB,IAArB,CAA2B,CACzB,MAAOA,cAAP,CACD,CAFD,IAEO,CACL,MAAO,MAAKC,SAAL,CAAehB,GAAf,CAAP,CACD,CACF,C,wEAEuBA,G,CAA6B,CACnD,MAAO,MAAKiB,eAAL,CAAqBjB,GAArB,CAAP,CACD,C,4EAEyBA,G,CAA4B,CACpD,MAAO,MAAKiB,eAAL,CAAqBjB,GAArB,EAA0BU,IAA1B,CAA+B,SAACL,KAAD,CAAkB,CACtD,MAAO,CACLa,MAAOb,MAAMa,KADR,CAELC,OAAQd,MAAMc,MAFT,CAAP,CAID,CALM,CAAP,CAMD,C,wDAGYtB,c","file":"RCTImageLoader.js","sourcesContent":["/**\n * @providesModule RCTImageLoader\n * @flow\n */\n\nimport RCTBridge, {\n  RCT_EXPORT_MODULE,\n  RCT_EXPORT_METHOD,\n  RCTFunctionTypeNormal,\n  RCTFunctionTypePromise\n} from \"RCTBridge\";\n\n@RCT_EXPORT_MODULE(\"RCTImageLoader\")\nclass RCTImageLoader {\n  bridge: RCTBridge;\n\n  imageCache: { [cacheKey: string]: Promise<Image> };\n\n  constructor(bridge: RCTBridge) {\n    this.bridge = bridge;\n    this.imageCache = {};\n  }\n\n  loadImage(url: string): Promise<Image> {\n    const loadPromise = new Promise((resolve, reject) => {\n      const image = new Image();\n      image.src = url;\n\n      // skip decoding/loading on data uris\n      if (url.startsWith(\"data:\")) return resolve(image);\n\n      // $FlowFixMe: libdef\n      if (typeof image.decode === \"function\") {\n        image\n          .decode()\n          .then(() => {\n            resolve(image);\n          })\n          .catch((err) => {\n            reject(err);\n          });\n      } else {\n        image.onload = () => resolve(image);\n        image.onerror = () => reject();\n      }\n    });\n\n    this.imageCache[url] = loadPromise;\n\n    return loadPromise;\n  }\n\n  getImagePromise(url: string): Promise<Image> {\n    const existingImage = this.imageCache[url];\n    if (existingImage != null) {\n      return existingImage;\n    } else {\n      return this.loadImage(url);\n    }\n  }\n\n  loadImageWithURLRequest(url: string): Promise<Image> {\n    return this.getImagePromise(url);\n  }\n\n  getImageSizeForURLRequest(url: string): Promise<Size> {\n    return this.getImagePromise(url).then((image: Image) => {\n      return {\n        width: image.width,\n        height: image.height\n      };\n    });\n  }\n}\n\nexport default RCTImageLoader;\n"]}